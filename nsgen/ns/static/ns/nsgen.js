//
//  NGSen extension to graphui.js.
//


class ConnectionRulesNSGen extends ConnectionRulesBase {
  // bare-bones rules determining whether and how nodes can be connected
  static canConnect(a1, a2, could=false) {
    //  universal
    let ta = a2.i_o && !a1.i_o; // a1 is input and a2 is output anchor
    let tc = a1.idx==-1 && a2.idx==-1; // both are center anchors
    if (!ta && !tc) return false;

    // flowchart
    let fctypes = ConnectionRulesNSGen.fctypes;
    let isflowchart = (fctypes.indexOf(a1.owner.owner.basetype)>=0 && fctypes.indexOf(a2.owner.owner.basetype)>=0);
    if (isflowchart) {
      // output nodes must have a well-defined destination
      let tfc1 = a1.numconnections == 0;
      let tfc2 = a1.idx!=-1 && a2.idx!=-1; // we don't want to connect fc nodes by their centers!
      return (tfc1 || could) && tfc2;
    }

    // datagraph
    let isdatagraph = (fctypes.indexOf(a1.owner.owner.basetype)==-1 && fctypes.indexOf(a2.owner.owner.basetype)==-1);
    if (isdatagraph) {
      // method links
      if (a1.idx==-1 && a2.idx==-1) {
        let tpe1 = a1.owner.owner.basetype;
        let tpe2 = a2.owner.owner.basetype;
        let t1 = tpe1 == "object" && tpe2 == "method";
        let t2 = tpe1 == "method" && tpe2 == "object";
        let t3 = a1.numconnections == 0;
        let t4 = a2.numconnections == 0;
        return t1 && (t4 || could) || (t2 && (t3 || could) );
      }
      // type matches or wildcard (pseudo-polymorphism, since not uni-directional)
      let t5 = a1.type == a2.type;
      let t6 = a1.type == '' || a2.type == '';
      let t7 = a1.type == 'obj' || a2.type == 'obj';
      // input nodes must have a well-defined origin
      let t8 = a2.numconnections == 0
      return (t5 || t6 || t7) && (t8 || could);
    }

    // a proper combo goes in the right direction from fc node to dg node
    let iscombo = (fctypes.indexOf(a1.owner.owner.basetype)>=0 && fctypes.indexOf(a2.owner.owner.basetype)==-1);
    if (iscombo) {
      // process nodes assigned to objects
      let tcb_1 = a2.owner.owner.basetype == "object"; // want resulting in an assignment statemen
      let tcb_2 = a1.owner.owner.basetype == "proc"; // only procs can execute for now
      let tcb_3 = a1.numconnections == 0;

      // decision nodes connected to (boolean evaluation) functions
      // TODO: maybe use returnfuncs, but functions may always be enterprited as booleans
      //       through false === false, zero or null; true === otherwise.
      // OR:   introduce a retfunc which is just a (bool/int returning) func that
      //       happily becomes white/active even without a target obj to catch
      //       its output value
      let tcb_1b = a2.owner.owner.basetype == "function_named";
      let tcb_2b = a1.owner.owner.basetype == "dec";
      let tcb_3b = a1.numconnections == 0;

      return (tcb_1 && tcb_2 && tcb_3) || (tcb_1b && tcb_2b && tcb_3b);
    }

    // nether, undefined
    return false;
  }
  static couldConnect(a1, a2) {
    return ConnectionRulesNSGen.canConnect(a1, a2, true);
  }
  static getLinkBasetype(a1, a2) {
    let fctypes = ConnectionRulesNSGen.fctypes;
    let t1 = fctypes.indexOf(a1.owner.owner.basetype)>=0 && fctypes.indexOf(a2.owner.owner.basetype)==-1;
    let t2 = (a1.idx==-1 && a2.idx==-1);
    if (t1 && t2)
      return "link_straight";
    else if (t2)
      return "link_double_center";
    else
      return "link_single";
  }
  static canConverge(basetypeUp, basetypeDown) {
    let t1 = ConnectionRulesNSGen.fctypes.indexOf(basetypeUp) >= 0;
    let t2 = ConnectionRulesNSGen.fctypes.indexOf(basetypeDown) >= 0;
    return t1 && t2;
  }
  static canDiverge(basetypeUp, basetypeDown) {
    let t1 = ConnectionRulesNSGen.fctypes.indexOf(basetypeUp) == -1;
    let t2 = ConnectionRulesNSGen.fctypes.indexOf(basetypeDown) == -1;
    return t1 && t2;
  }
}
ConnectionRulesNSGen.fctypes = ['term', 'proc', 'dec'];

class UserTypeTree {
  constructor(typetree) {
    this.tpes = typetree["tpes"];
    this.functions = typetree["functions"];
    this.methods = typetree["methods"];
  }

}

class GraphInterfaceNSGen extends GraphInterface {
  constructor(gs_id, tab_id) {
    super(gs_id, tab_id, ConnectionRulesNSGen);

    this.allSessionData = null;
  }
  // server communication
  ajaxcall(url, data, success_cb, fail_cb=null) {
    this.isalive = simpleajax(url, data, this.gs_id, this.tab_id, success_cb, fail_cb, true);
  }
  ajaxcall_noerror(url, data, success_cb) {
    // call with showfail=false, which turns off django and offline fails
    this.isalive = simpleajax(url, data, this.gs_id, this.tab_id, success_cb, null, false);
  }
  loadSession() {
    $("body").css("cursor", "wait");
    // TODO: simplify - server can extract gs_id from the standard request generated by ajaxcall
    this.ajaxcall("/ajax_load/" + this.gs_id, null, function(obj) {
      let error = obj["error"];
      // be explicit about this error
      if (obj["graphdef"] == undefined) {
        alert("no graphdef found in session");
        return;
      }
      // handle server data
      if (error == null) {
        this.reset();
        // set base type tree to match addresses
        intface.setTypeTree(obj);
        // our own custom handle
        this.allSessionData = obj;
        this.injectGraphDefinition(obj["graphdef"]);
        fireEvents(this._onLoadListn, "sessionLoad", obj);
      } else {
        alert(error);
      }
      $("body").css("cursor", "default");
    }.bind(this));
  }
  commitSession() {
    $("body").css("cursor", "wait");
    // allSessionData contains live type trees, and a graphdef slow
    let gd = this.graphData.extractGraphDefinition();
    console.log(gd);
    this.allSessionData['graphdef'] = gd;
    this.ajaxcall("/ajax_commit/", this.allSessionData, function(obj) {
      $("body").css("cursor", "default");
    }.bind(this));
  }
  _resizeCB() {
    let btnsmenu = d3.select("#buttons");
    btnsmenu.style("left", window.innerWidth/2-btnsmenu.node().clientWidth/2 + "px");

    // TODO: move this out into graphs.html and put in a resize cb? (localization)
    //let tpeedt = d3.select("#tpeedt_1");
    let tpeedt = d3.select("#tpeedt_wrapper");
    let w = tpeedt.node().getBoundingClientRect().width;
    tpeedt.style("left", window.innerWidth - w + "px");
  }
}


function simpleajax(url, data, gs_id, tab_id, success_cb, fail_cb=null, showfail=true) {
  // GraphInterface utility function
  let isalive = true;
  $.ajax({
    type: "POST",
    url: url,
    data: { "gs_id": gs_id, "tab_id": tab_id, "data_str" : JSON.stringify(data) },
  })
  .fail(function(xhr, statusText, errorThrown) {
    if (!showfail) return
    if (fail_cb) fail_cb();
    $("body").css("cursor", "default");
    $(window.open().document.body).html(errorThrown + xhr.status + xhr.responseText);
  })
  .success(function(msg) {
    // parse & json errors
    try {
      obj = JSON.parse(msg);
    }
    catch(error) {
      console.log("JSON.parse error on server response: ", msg);
      alert("JSON.parse error on server response: ", msg);
      throw error;
    }

    // fatal errors
    let fatalerror = obj["fatalerror"];
    if (fatalerror) {
      isalive = false;
      alert("Please restart the session. Fatal error: " + fatalerror);
      //location.reload();
      close();
    }

    // timeouts
    let timeout = obj["timeout"];
    if (timeout) {
      alert("timeout: " + timeout);
    }

    // pass it on
    success_cb(obj)
  });
  return isalive;
}


//  base node types
class NodeFCTerm extends Node {
  static get basetype() { return "term"; }
  get basetype() { return NodeFCTerm.basetype; }
  static get prefix() { return "t"; }
  constructor(x, y, id, name, label, typeconf) {
    if (id == "" && label == "") label = id;
    super(x, y, id, name, label, typeconf);
  }
  _getGNType() {
    return GraphicsNodeSquare;
  }
  _getAnchorType() {
    return AnchorSquare;
  }
  isConnected(connectivity) {
    return connectivity.indexOf(false) == -1;
  }
  isActive(connectivity) {
    return this.isConnected(connectivity);
  }
}


class NodeFCProcess extends NodeFCTerm {
  static get basetype() { return "proc"; }
  get basetype() { return NodeFCProcess.basetype; }
  static get prefix() { return "p"; }
  isConnected(connectivity) {
    return connectivity.indexOf(false) == -1;
  }
  isActive(connectivity) {
    let active = this.gNode.centerAnchor.numconnections > 0;
    let connected = this.isConnected(connectivity);
    return connected && active;
  }
}


class NodeFCDec extends Node {
  static get basetype() { return "dec"; }
  get basetype() { return NodeFCDec.basetype; }
  static get prefix() { return "d"; }
  constructor(x, y, id, name, label, typeconf) {
    if (id == "" && label == "") label = id;
    super(x, y, id, name, label, typeconf);
  }
  _getGNType() {
    return GraphicsNodeDiamond;
  }
  _getAnchorType() {
    return AnchorCircular;
  }
  isConnected(connectivity) {
    return connectivity.indexOf(false) == -1;
  }
  isActive(connectivity) {
    let active = this.gNode.centerAnchor.numconnections > 0;
    let connected = this.isConnected(connectivity);
    return connected && active;
  }
}


NodeLinkConstrucionHelper.register_node_class(NodeFCTerm);
NodeLinkConstrucionHelper.register_node_class(NodeFCProcess);
NodeLinkConstrucionHelper.register_node_class(NodeFCDec);
